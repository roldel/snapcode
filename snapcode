#!/bin/sh
# snapcode — create an LLM-friendly text snapshot of your codebase.

set -e

# -------- Configuration --------
ORIGINAL_CWD="$(pwd)"
OUTPUT_FILE="snapshot_report.txt"
SCRIPT_PATH="$0"
TARGETS=""

# Flags
IGNORE_FILES=""
INCLUDE_ROOT_GITIGNORE=0
NO_IGNORE=0
ASSUME_YES=0

# -------- Usage --------
print_usage() {
    cat <<'EOF'
Usage: snapcode [options] [directories...]

Options:
  --path <DIR>                 Add a directory to snapshot (can be repeated)
  --output <FILE>              Write report to this file (default: ./snapshot_report.txt)
                               Use "-" to output to stdout

  --ignore <RULEFILE>          Add custom ignore file (standard gitignore syntax)
  --include-root-gitignore     Also respect .gitignore in the current directory (when using custom ignores)

  --no-ignore                  Disable all filtering (dumps everything except .git)
  --yes                        Auto-answer yes to prompts

  -h, --help                   Show this help

Description:
  snapcode generates a text snapshot of your code.
  It strictly respects your .gitignore rules to determine what to include.
  Binary files are detected and skipped.
EOF
}

# -------- Helper to add targets --------
add_target() {
    if [ -d "$1" ]; then
        ABS_PATH="$(cd "$1" 2>/dev/null && pwd)"
        TARGETS="$TARGETS$ABS_PATH
"
    else
        echo "Error: Invalid path: $1" >&2; exit 1
    fi
}

# -------- Parse arguments --------
while [ $# -gt 0 ]; do
    case "$1" in
        --path)
            [ $# -ge 2 ] || { echo "Error: --path requires a directory" >&2; exit 1; }
            add_target "$2"; shift 2 ;;
        --output)
            [ $# -ge 2 ] || { echo "Error: --output requires a file" >&2; exit 1; }
            OUTPUT_FILE="$2"; shift 2 ;;
        --ignore)
            [ $# -ge 2 ] || { echo "Error: --ignore requires a file" >&2; exit 1; }
            IGNORE_FILES="${IGNORE_FILES}${IGNORE_FILES:+ }$2"; shift 2 ;;
        --include-root-gitignore)
            INCLUDE_ROOT_GITIGNORE=1; shift ;;
        --no-ignore)
            NO_IGNORE=1; shift ;;
        --yes)
            ASSUME_YES=1; shift ;;
        -h|--help)
            print_usage; exit 0 ;;
        --) shift; break ;;
        -*)
            echo "Unknown option: $1" >&2; print_usage; exit 1 ;;
        *) 
            add_target "$1"; shift ;;
    esac
done

for arg in "$@"; do add_target "$arg"; done
if [ -z "$TARGETS" ]; then add_target "."; fi

# -------- Resolve Output Path --------
case "$OUTPUT_FILE" in
    /*) : ;;
    -)  OUTPUT_FILE="-" ;;
    *)  OUTPUT_FILE="$ORIGINAL_CWD/$OUTPUT_FILE" ;;
esac

if [ "$OUTPUT_FILE" != "-" ]; then : > "$OUTPUT_FILE"; fi

# -------- Ignore Logic --------
TMP_IGNORE=""
cleanup() { [ -n "$TMP_IGNORE" ] && [ -f "$TMP_IGNORE" ] && rm -f "$TMP_IGNORE"; }
trap cleanup EXIT INT TERM

combine_ignores() {
    TMP_IGNORE="$(mktemp || mktemp -t snapcode_ignore.XXXXXX)"
    : > "$TMP_IGNORE"
    for f in $IGNORE_FILES; do
        [ -f "$f" ] && cat "$f" >> "$TMP_IGNORE" && echo >> "$TMP_IGNORE"
    done
    if [ "$INCLUDE_ROOT_GITIGNORE" -eq 1 ] && [ -f "$ORIGINAL_CWD/.gitignore" ]; then
        cat "$ORIGINAL_CWD/.gitignore" >> "$TMP_IGNORE"
        echo >> "$TMP_IGNORE"
    fi
}

USE_CUSTOM=0
if [ -n "$IGNORE_FILES" ]; then
    combine_ignores
    [ -s "$TMP_IGNORE" ] && USE_CUSTOM=1
fi

# -------- Safety Prompt --------
if [ "$NO_IGNORE" -eq 0 ] && [ "$ASSUME_YES" -eq 0 ] && [ "$USE_CUSTOM" -eq 0 ]; then
    IS_SAFE=0
    
    # Check if we are inside a git work tree
    if command -v git >/dev/null 2>&1; then
        if git -C "$ORIGINAL_CWD" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            IS_SAFE=1
        fi
    fi
    
    # Fallback: Check if local .gitignore exists
    if [ "$IS_SAFE" -eq 0 ] && [ -f "$ORIGINAL_CWD/.gitignore" ]; then
        IS_SAFE=1
    fi

    if [ "$IS_SAFE" -eq 0 ]; then
        echo "Warning: No git repository detected and no .gitignore found."
        echo "This will dump EVERY file in the target directories."
        printf "Continue? [y/N] "
        read -r ans
        case "$ans" in [yY]*) ;; *) echo "Aborted."; exit 1 ;; esac
    fi
fi

# -------- Checks --------

is_ignored() {
    local path="$1"
    
    # 1. Hard exclusions
    case "$path" in
        */.git|*/.git/*|.git|.git/*) return 0 ;;
    esac
    if [ "$OUTPUT_FILE" != "-" ] && [ "$path" -ef "$OUTPUT_FILE" ]; then return 0; fi
    if [ "$path" -ef "$SCRIPT_PATH" ]; then return 0; fi

    # 2. No Ignore Mode
    [ "$NO_IGNORE" -eq 1 ] && return 1

    # 3. Custom Ignores
    if [ "$USE_CUSTOM" -eq 1 ]; then
        git -C "$ORIGINAL_CWD" -c core.excludesFile="$TMP_IGNORE" check-ignore --no-index -q -- "$path" 2>/dev/null && return 0
    fi

    # 4. Standard Git Ignore (Context Aware)
    local dir_context
    if [ -d "$path" ]; then dir_context="$path"; else dir_context="$(dirname "$path")"; fi
    
    if git -C "$dir_context" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        git -C "$dir_context" check-ignore -q -- "$path" 2>/dev/null && return 0
    fi

    return 1
}

is_binary() {
    if command -v grep >/dev/null; then
        ! grep -Iq . "$1" 2>/dev/null && [ -s "$1" ]
    else
        return 1
    fi
}

# -------- Processing --------

append_file() {
    local file="$1"
    
    if is_ignored "$file"; then return; fi

    echo "===== File: $file ====="
    
    if [ ! -r "$file" ]; then
        echo "[Error: file not readable]"
    elif is_binary "$file"; then
        echo "[Binary file skipped]"
    else
        cat "$file" || echo "[Error: could not read file]"
    fi
    echo
    echo
}

print_contents() {
    local dir="$1"

    # Iterate over ALL files, including dotfiles
    for item in "$dir"/* "$dir"/.*; do
        # Handle cases where expansion fails (empty dir)
        [ -e "$item" ] || [ -L "$item" ] || continue
        
        # Exclude special directory entries . and ..
        local base
        base="$(basename "$item")"
        if [ "$base" = "." ] || [ "$base" = ".." ]; then continue; fi
        
        # Exclude .git folder
        if [ "$base" = ".git" ]; then continue; fi

        if [ -d "$item" ]; then
            [ -L "$item" ] && continue
            
            if is_ignored "$item"; then continue; fi
            
            print_contents "$item"
        elif [ -f "$item" ]; then
            append_file "$item"
        fi
    done
}

process_root() {
    local ROOT="$1"
    [ -z "$ROOT" ] && return

    echo
    echo "################################################"
    echo "# SECTION ROOT: $ROOT"
    echo "################################################"
    echo

    echo "===== Directory Tree ($ROOT) ====="
    (
        cd "$ROOT" || return
        if command -v tree >/dev/null 2>&1; then
            if tree --help 2>&1 | grep -q -- --gitignore; then
                 tree -a --dirsfirst --gitignore -I ".git"
            else
                 tree -a --dirsfirst -I ".git"
            fi
        else
            find . -path './.git' -prune -o -print | sed -e 's;[^/]*/;│   ;g;s;│   \([^│ ]\);├── \1;'
        fi
    )
    echo

    echo "===== File Contents ($ROOT) ====="
    echo
    print_contents "$ROOT"
}

generate_report() {
    echo "===== snapcode Report ====="
    echo "Generated: $(date)"
    printf %s "$TARGETS" | while IFS= read -r target; do
        process_root "$target"
    done
}

# -------- Main --------
if [ "$OUTPUT_FILE" = "-" ]; then
    generate_report
else
    generate_report > "$OUTPUT_FILE"
    echo "Done! Snapshot saved to: $OUTPUT_FILE"
fi