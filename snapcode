#!/bin/sh
# snapcode — create an LLM-friendly text snapshot of your codebase.

set -e

# -------- Defaults --------
ORIGINAL_CWD="$(pwd)"              # Where the command is run from
ROOT="$ORIGINAL_CWD"               # Default target is current dir
OUTPUT_FILE="snapshot_report.txt"  # Default filename
SCRIPT_PATH="$0"

# Ignore control
IGNORE_FILES=""
INCLUDE_ROOT_GITIGNORE=0
NO_IGNORE=0
ASSUME_YES=0

print_usage() {
    cat <<'EOF'
Usage: snapcode [options] [directory]

Options:
  --path <DIR>                 Snapshot starting from this directory (default: current)
  --output <FILE>              Write report to this file (default: ./snapshot_report.txt)
                               Use "-" to output to stdout

  --ignore <RULEFILE>          Add ignore file (gitignore syntax). Repeatable.
  --include-root-gitignore     Also respect <DIR>/.gitignore when using custom ignores

  --no-ignore                  Disable all filtering (full dump, skips safety prompt)
  --yes                        Auto-answer yes to prompts (non-interactive)

  -h, --help                   Show this help

Examples:
  snapcode src/lib
  snapcode --output context.txt src/lib
EOF
}

# -------- Parse arguments --------
while [ $# -gt 0 ]; do
    case "$1" in
        --path)
            [ $# -ge 2 ] || { echo "Error: --path requires a directory" >&2; exit 1; }
            ROOT="$2"; shift 2 ;;
        --output)
            [ $# -ge 2 ] || { echo "Error: --output requires a file" >&2; exit 1; }
            OUTPUT_FILE="$2"; shift 2 ;;
        --ignore)
            [ $# -ge 2 ] || { echo "Error: --ignore requires a file" >&2; exit 1; }
            IGNORE_FILES="${IGNORE_FILES}${IGNORE_FILES:+ }$2"; shift 2 ;;
        --include-root-gitignore)
            INCLUDE_ROOT_GITIGNORE=1; shift ;;
        --no-ignore)
            NO_IGNORE=1; shift ;;
        --yes)
            ASSUME_YES=1; shift ;;
        -h|--help)
            print_usage; exit 0 ;;
        --) shift; break ;;
        -*)
            echo "Unknown option: $1" >&2; print_usage; exit 1 ;;
        *) break ;;
    esac
done

# -------- Handle Positional Argument --------
# If a directory is provided without --path, use it
if [ $# -gt 0 ]; then
    ROOT="$1"
fi

# -------- Normalize Target Path (ROOT) --------
if ! ROOT="$(cd "$ROOT" 2>/dev/null && pwd)"; then
    echo "Error: Invalid path: $ROOT" >&2; exit 1
fi

# -------- Resolve Output Path --------
# If path is relative, anchor it to ORIGINAL_CWD, not ROOT
case "$OUTPUT_FILE" in
    /*) : ;; # Absolute path, do nothing
    -)  OUTPUT_FILE="-" ;;
    *)  OUTPUT_FILE="$ORIGINAL_CWD/$OUTPUT_FILE" ;;
esac

# Create/Touch output file immediately to ensure -ef works
if [ "$OUTPUT_FILE" != "-" ]; then
    : > "$OUTPUT_FILE"
fi

# -------- Ignore handling --------
TMP_IGNORE=""
cleanup() { [ -n "$TMP_IGNORE" ] && [ -f "$TMP_IGNORE" ] && rm -f "$TMP_IGNORE"; }
trap cleanup EXIT INT TERM

combine_ignores() {
    TMP_IGNORE="$(mktemp || mktemp -t snapcode_ignore.XXXXXX)"
    : > "$TMP_IGNORE"
    for f in $IGNORE_FILES; do
        [ -f "$f" ] && cat "$f" >> "$TMP_IGNORE" && echo >> "$TMP_IGNORE"
    done
    if [ "$INCLUDE_ROOT_GITIGNORE" -eq 1 ] && [ -f "$ROOT/.gitignore" ]; then
        cat "$ROOT/.gitignore" >> "$TMP_IGNORE"
        echo >> "$TMP_IGNORE"
    fi
}

USE_IGNORE=0
USE_CUSTOM=0
USE_GIT_DEFAULT=0

if [ "$NO_IGNORE" -eq 0 ]; then
    if [ -n "$IGNORE_FILES" ]; then
        combine_ignores
        [ -s "$TMP_IGNORE" ] && USE_IGNORE=1 && USE_CUSTOM=1
    elif [ -f "$ROOT/.gitignore" ]; then
        USE_IGNORE=1
        USE_GIT_DEFAULT=1
    fi
fi

# -------- Safety prompt --------
if [ "$USE_IGNORE" -eq 0 ] && [ "$ASSUME_YES" -eq 0 ] && [ "$NO_IGNORE" -eq 0 ]; then
    echo "Warning: No ignore rules active → this will dump EVERY file in:"
    echo "  $ROOT"
    printf "Continue? [y/N] "
    read -r ans
    case "$ans" in [yY]*) ;; *) echo "Aborted."; exit 1 ;; esac
fi

# -------- Generator Function --------
generate_report() {
    echo "===== snapcode Report ====="
    echo "Root: $ROOT"
    echo "Generated: $(date)"
    if [ "$USE_IGNORE" -eq 1 ]; then
        [ "$USE_CUSTOM" -eq 1 ] && echo "Ignore: custom rules" || echo "Ignore: root .gitignore"
    else
        echo "Ignore: none (full dump)"
    fi
    echo

    # -------- Directory tree --------
    cd "$ROOT"
    echo "===== Directory Tree ====="
    
    # Check if the output file is physically inside the root we are scanning
    # If so, we need to hide it from the tree
    TREE_IGNORE=".git"
    if [ "$OUTPUT_FILE" != "-" ]; then
         # Check if OUTPUT_FILE starts with ROOT
         case "$OUTPUT_FILE" in
            "$ROOT"*)
                OUT_BASENAME="$(basename "$OUTPUT_FILE")"
                TREE_IGNORE="$TREE_IGNORE|$OUT_BASENAME"
                ;;
         esac
    fi

    if command -v tree >/dev/null 2>&1; then
        tree -a --dirsfirst -I "$TREE_IGNORE"
    else
        echo "(tree not available — using find fallback)"
        find . -path './.git' -prune -o -print \
        | sed -e 's;[^/]*/;│   ;g;s;│   \([^│ ]\);├── \1;'
    fi
    echo

    # -------- File contents --------
    echo "===== File Contents ====="
    echo
    print_contents "$ROOT"
}

is_ignored() {
    [ "$USE_IGNORE" -eq 0 ] && return 1
    command -v git >/dev/null 2>&1 || return 1
    if [ "$USE_CUSTOM" -eq 1 ]; then
        git -c core.excludesFile="$TMP_IGNORE" check-ignore --no-index -q -- "$1" 2>/dev/null
    else
        git check-ignore -q -- "$1" 2>/dev/null || git check-ignore --no-index -q -- "$1" 2>/dev/null
    fi
}

append_file() {
    file="$1"

    # CRITICAL FIX: Prevent infinite loop / corruption
    if [ "$OUTPUT_FILE" != "-" ] && [ "$file" -ef "$OUTPUT_FILE" ]; then return; fi
    
    # Skip self
    if [ "$file" -ef "$SCRIPT_PATH" ]; then return; fi

    case "$file" in
        */.git|*/.git/*|.git|.git/*) return ;;
    esac

    if is_ignored "$file"; then return; fi

    echo "===== File: $file ====="
    if [ -r "$file" ]; then
        cat "$file" || echo "[Error: could not read file]"
    else
        echo "[Error: file not readable]"
    fi
    echo
    echo
}

print_contents() {
    dir="$1"

    for sample in "$dir"/.env.sample "$dir"/.env.example; do
        [ -f "$sample" ] && append_file "$sample"
    done

    for item in "$dir"/*; do
        [ -e "$item" ] || [ -L "$item" ] || continue

        if [ -d "$item" ] && [ "$(basename "$item")" = ".git" ]; then
            continue
        fi

        if [ -d "$item" ]; then
            [ -L "$item" ] && continue
            print_contents "$item"
        elif [ -f "$item" ]; then
            append_file "$item"
        fi
    done
}

# -------- Execution --------
if [ "$OUTPUT_FILE" = "-" ]; then
    generate_report
else
    generate_report > "$OUTPUT_FILE"
    echo "Done! Snapshot saved to: $OUTPUT_FILE"
fi
