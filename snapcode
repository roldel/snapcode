#!/bin/sh
# snapcode — create an LLM-friendly text snapshot of your codebase.

set -e

# -------- Defaults --------
ORIGINAL_CWD="$(pwd)"              # Where the command is run from
OUTPUT_FILE="snapshot_report.txt"  # Default filename
SCRIPT_PATH="$0"

# Target collection (newline separated string)
TARGETS=""

# Ignore control
IGNORE_FILES=""
INCLUDE_ROOT_GITIGNORE=0
NO_IGNORE=0
ASSUME_YES=0

print_usage() {
    cat <<'EOF'
Usage: snapcode [options] [directories...]

Options:
  --path <DIR>                 Add a directory to snapshot (can be repeated)
  --output <FILE>              Write report to this file (default: ./snapshot_report.txt)
                               Use "-" to output to stdout

  --ignore <RULEFILE>          Add ignore file (gitignore syntax). Repeatable.
  --include-root-gitignore     Also respect .gitignore in the current directory

  --no-ignore                  Disable all filtering (full dump, skips safety prompt)
  --yes                        Auto-answer yes to prompts (non-interactive)

  -h, --help                   Show this help

Examples:
  snapcode src/lib src/utils
  snapcode --path backend --path frontend --output full_stack.txt
EOF
}

# -------- Helper to add targets --------
add_target() {
    # Normalize path immediately
    if [ -d "$1" ]; then
        ABS_PATH="$(cd "$1" 2>/dev/null && pwd)"
        TARGETS="$TARGETS$ABS_PATH
"
    else
        echo "Error: Invalid path: $1" >&2; exit 1
    fi
}

# -------- Parse arguments --------
while [ $# -gt 0 ]; do
    case "$1" in
        --path)
            [ $# -ge 2 ] || { echo "Error: --path requires a directory" >&2; exit 1; }
            add_target "$2"; shift 2 ;;
        --output)
            [ $# -ge 2 ] || { echo "Error: --output requires a file" >&2; exit 1; }
            OUTPUT_FILE="$2"; shift 2 ;;
        --ignore)
            [ $# -ge 2 ] || { echo "Error: --ignore requires a file" >&2; exit 1; }
            IGNORE_FILES="${IGNORE_FILES}${IGNORE_FILES:+ }$2"; shift 2 ;;
        --include-root-gitignore)
            INCLUDE_ROOT_GITIGNORE=1; shift ;;
        --no-ignore)
            NO_IGNORE=1; shift ;;
        --yes)
            ASSUME_YES=1; shift ;;
        -h|--help)
            print_usage; exit 0 ;;
        --) shift; break ;; # Stop parsing flags, rest are targets
        -*)
            echo "Unknown option: $1" >&2; print_usage; exit 1 ;;
        *) 
            # Treat positional argument as a target
            add_target "$1"; shift ;;
    esac
done

# If arguments remain after '--', add them
for arg in "$@"; do
    add_target "$arg"
done

# Default to current directory if no targets specified
if [ -z "$TARGETS" ]; then
    add_target "."
fi

# -------- Resolve Output Path --------
# If path is relative, anchor it to ORIGINAL_CWD
case "$OUTPUT_FILE" in
    /*) : ;; # Absolute path, do nothing
    -)  OUTPUT_FILE="-" ;;
    *)  OUTPUT_FILE="$ORIGINAL_CWD/$OUTPUT_FILE" ;;
esac

# Create/Touch output file immediately to ensure -ef works
if [ "$OUTPUT_FILE" != "-" ]; then
    : > "$OUTPUT_FILE"
fi

# -------- Ignore handling --------
TMP_IGNORE=""
cleanup() { [ -n "$TMP_IGNORE" ] && [ -f "$TMP_IGNORE" ] && rm -f "$TMP_IGNORE"; }
trap cleanup EXIT INT TERM

combine_ignores() {
    TMP_IGNORE="$(mktemp || mktemp -t snapcode_ignore.XXXXXX)"
    : > "$TMP_IGNORE"
    for f in $IGNORE_FILES; do
        [ -f "$f" ] && cat "$f" >> "$TMP_IGNORE" && echo >> "$TMP_IGNORE"
    done
    # Use ORIGINAL_CWD for the root gitignore check since we might have multiple roots
    if [ "$INCLUDE_ROOT_GITIGNORE" -eq 1 ] && [ -f "$ORIGINAL_CWD/.gitignore" ]; then
        cat "$ORIGINAL_CWD/.gitignore" >> "$TMP_IGNORE"
        echo >> "$TMP_IGNORE"
    fi
}

USE_IGNORE=0
USE_CUSTOM=0

if [ "$NO_IGNORE" -eq 0 ]; then
    if [ -n "$IGNORE_FILES" ]; then
        combine_ignores
        [ -s "$TMP_IGNORE" ] && USE_IGNORE=1 && USE_CUSTOM=1
    elif [ -f "$ORIGINAL_CWD/.gitignore" ]; then
        # Fallback to gitignore in current dir if no custom files provided
        USE_IGNORE=1
    fi
fi

# -------- Safety prompt --------
if [ "$USE_IGNORE" -eq 0 ] && [ "$ASSUME_YES" -eq 0 ] && [ "$NO_IGNORE" -eq 0 ]; then
    echo "Warning: No ignore rules active → this will dump EVERY file in the targets."
    printf "Continue? [y/N] "
    read -r ans
    case "$ans" in [yY]*) ;; *) echo "Aborted."; exit 1 ;; esac
fi

# -------- Check Ignore Function --------
is_ignored() {
    [ "$USE_IGNORE" -eq 0 ] && return 1
    command -v git >/dev/null 2>&1 || return 1
    
    # We always run check-ignore from ORIGINAL_CWD to respect relative paths correctly
    # or rely on absolute path matching.
    if [ "$USE_CUSTOM" -eq 1 ]; then
        git -C "$ORIGINAL_CWD" -c core.excludesFile="$TMP_IGNORE" check-ignore --no-index -q -- "$1" 2>/dev/null
    else
        # Standard git ignore check
        git -C "$ORIGINAL_CWD" check-ignore -q -- "$1" 2>/dev/null || \
        git -C "$ORIGINAL_CWD" check-ignore --no-index -q -- "$1" 2>/dev/null
    fi
}

# -------- Output Helpers --------

append_file() {
    file="$1"

    # Avoid self-reference
    if [ "$OUTPUT_FILE" != "-" ] && [ "$file" -ef "$OUTPUT_FILE" ]; then return; fi
    if [ "$file" -ef "$SCRIPT_PATH" ]; then return; fi

    case "$file" in
        */.git|*/.git/*|.git|.git/*) return ;;
    esac

    if is_ignored "$file"; then return; fi

    echo "===== File: $file ====="
    if [ -r "$file" ]; then
        cat "$file" || echo "[Error: could not read file]"
    else
        echo "[Error: file not readable]"
    fi
    echo
    echo
}

print_contents() {
    dir="$1"

    for sample in "$dir"/.env.sample "$dir"/.env.example; do
        [ -f "$sample" ] && append_file "$sample"
    done

    for item in "$dir"/*; do
        [ -e "$item" ] || [ -L "$item" ] || continue

        if [ -d "$item" ] && [ "$(basename "$item")" = ".git" ]; then
            continue
        fi

        if [ -d "$item" ]; then
            [ -L "$item" ] && continue
            print_contents "$item"
        elif [ -f "$item" ]; then
            append_file "$item"
        fi
    done
}

process_root() {
    ROOT="$1"
    [ -z "$ROOT" ] && return

    echo
    echo "################################################"
    echo "# SECTION ROOT: $ROOT"
    echo "################################################"
    echo

    # -------- Directory tree --------
    echo "===== Directory Tree ($ROOT) ====="
    
    # Check if the output file is physically inside the root we are scanning
    TREE_IGNORE=".git"
    if [ "$OUTPUT_FILE" != "-" ]; then
         case "$OUTPUT_FILE" in
            "$ROOT"*)
                OUT_BASENAME="$(basename "$OUTPUT_FILE")"
                TREE_IGNORE="$TREE_IGNORE|$OUT_BASENAME"
                ;;
         esac
    fi

    # Run tree from the perspective of the root
    (
        cd "$ROOT" || return
        if command -v tree >/dev/null 2>&1; then
            tree -a --dirsfirst -I "$TREE_IGNORE"
        else
            echo "(tree not available — using find fallback)"
            find . -path './.git' -prune -o -print \
            | sed -e 's;[^/]*/;│   ;g;s;│   \([^│ ]\);├── \1;'
        fi
    )
    echo

    # -------- File contents --------
    echo "===== File Contents ($ROOT) ====="
    echo
    print_contents "$ROOT"
}

generate_report() {
    echo "===== snapcode Report ====="
    echo "Generated: $(date)"
    
    if [ "$USE_IGNORE" -eq 1 ]; then
        [ "$USE_CUSTOM" -eq 1 ] && echo "Ignore: custom rules" || echo "Ignore: root .gitignore (auto-detected)"
    else
        echo "Ignore: none (full dump)"
    fi

    # Loop over targets (newline separated string)
    printf %s "$TARGETS" | while IFS= read -r target; do
        process_root "$target"
    done
}

# -------- Execution --------
if [ "$OUTPUT_FILE" = "-" ]; then
    generate_report
else
    generate_report > "$OUTPUT_FILE"
    echo "Done! Snapshot saved to: $OUTPUT_FILE"
fi